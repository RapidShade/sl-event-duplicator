<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Duplicate Event Widget v11.6.0</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
      padding: 0.5rem; 
      text-align: center; 
      color: #333; 
      background-color: #f9f9f9; 
      font-size: 14px;
      margin: 0;
    }
    #widget-container { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: flex-start; 
      height: 100%;
    }
    .hidden { display: none !important; }
    #loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
    .selector-container, #selection-state, #initial-state { 
      padding: 1rem; 
      background-color: white; 
      width: 100%; 
      box-sizing: border-box; 
      margin-top: 0.5rem; 
      border-radius: 8px;
    }
     #initial-state {
      border: 1px solid #ccc;
    }
    #selection-state, #period-selector-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
    }
    #selection-state p {
      margin: 0 1rem 0 0;
      text-align: left;
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #selection-state button {
      margin-top: 0;
      flex-shrink: 0; /* Prevents button from shrinking */
    }
    #period-selector-container select, #period-selector-container button {
        margin-top: 0;
    }
    #period-selector-container label {
        margin-right: 0.5rem;
    }
    #period-selector-container button + button {
        margin-left: 0.5rem;
    }
    select, button { 
      padding: 6px 12px; 
      margin-top: 10px; 
      border-radius: 4px; 
      border: 1px solid #ccc; 
      font-size: 13px;
    }
    button { background-color: #4CAF50; color: white; cursor: pointer; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    .cancel-button { background-color: #f44336; }
    #status { margin-top: 1rem; font-weight: bold; }
    .status-success { color: green; }
    .status-error   { color: red; }
    h2#widget-title { 
      font-size: 1em; 
      margin: 0 0 0.5rem 0; 
      color: #666;
      font-weight: normal;
    }
    #initial-state p, #selection-state p { margin-top: 0; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>
<div id="widget-container">
  <h2 id="widget-title">Duplicate Event Widget v11.6.0</h2>
  <div id="initial-state" class="selector-container">
    <p>Select an event in the table to begin.</p>
  </div>
  <div id="selection-state" class="selector-container hidden">
    <p id="selected-event-name"></p>
    <button id="start-duplication">Duplicate This Event</button>
  </div>
  <div id="processing-state" class="hidden">
    <div id="loader"></div>
    <p id="processing-message">Working...</p>
  </div>
  <div id="period-selector-container" class="selector-container hidden">
    <div>
        <label for="period-select">Select Target Period:</label>
        <select id="period-select"></select>
    </div>
    <div>
        <button id="confirm-duplication">Confirm & Duplicate</button>
        <button class="cancel-button" id="cancel-duplication">Cancel</button>
    </div>
  </div>
  <div id="status"></div>
</div>

<script>
  /**
   * RapidShade Duplicate Event Widget
   * Version: v11.6.0 (Fixed syntax error in initializeWidget try...catch block)
   */
  const WIDGET_VERSION = "v11.6.0";
  console.log(`RapidShade: Widget version ${WIDGET_VERSION}`);
  document.getElementById('widget-title').textContent = `Duplicate Event Widget ${WIDGET_VERSION}`;
  document.title = `Duplicate Event Widget ${WIDGET_VERSION}`;

  const config = {
    tables: {
      EVENTS: "Events", EXPENSES: "Expenses", EXPENSE_DETAILS: "ExpenseDetails",
      REVENUES: "Revenues", REVENUE_DETAILS: "RevenueDetails", PERIODS: "Periods",
    },
    columnIds: {
      EVENT_LINK: "Event",
      EXPENSE_LINK: "Expense",
      REVENUE_LINK: "Revenue",
      BUDGET_VERSION_LINK: "BudgetVersion"
    }
  };

  const FORMULA_AND_SYSTEM_COLUMNS_TO_EXCLUDE = [
      'CreatedAt', 'UpdatedAt', 'CreatedBy', 'UpdatedBy', 'DisplayStyle', 'EventCode',
      'Duplicate_Trigger', 'total_budgeted_expense', 'total_actual_expense', 'expense_diff',
      'expense_diff_percent', 'total_budgeted_revenue', 'total_actual_revenue', 'revenue_diff',
      'revenue_diff_percent', 'projected_budget', 'Target1', 'TargetKey1', 'Target2',
      'TargetKey2', 'Target3', 'TargetKey3', 'Variance', 'Viariance',
      'ExpCode', 'RevCode', 'Actual', 'Budget', 'Projected', 'ESID'
  ];

  let activeProcess = { resolvePeriod: null, sourceEventName: '' };
  let lastSelectedRecord = null;
  let tokenInfo = null;

  function setUIState(state, message = '') {
    console.log(`Setting UI state to: ${state}`, message);
    ['initial-state', 'selection-state', 'processing-state', 'period-selector-container'].forEach(id => {
        document.getElementById(id).classList.add('hidden');
    });
    document.getElementById('status').textContent = '';

    if (state === 'initial') { 
      document.getElementById('initial-state').classList.remove('hidden'); 
    } else if (state === 'selection') {
      document.getElementById('selection-state').classList.remove('hidden');
      document.getElementById('selected-event-name').textContent = message;
      document.getElementById('selected-event-name').title = message;
      activeProcess.sourceEventName = message;
    } else if (state === 'processing') {
      document.getElementById('processing-state').classList.remove('hidden');
      document.getElementById('processing-message').textContent = message;
    } else if (state === 'selectingPeriod') {
      document.getElementById('period-selector-container').classList.remove('hidden');
    } else if (['success', 'error'].includes(state)) {
      document.getElementById('status').textContent = message;
      document.getElementById('status').className = `status-${state}`;
      document.getElementById('selection-state').classList.remove('hidden');
    }
  }
  
  function cleanRecordData(recordFields) {
      const cleanedData = { ...recordFields };
      delete cleanedData.id;
      Object.keys(cleanedData).forEach(key => {
        if (key.startsWith('gristHelper_') || FORMULA_AND_SYSTEM_COLUMNS_TO_EXCLUDE.includes(key)) {
          delete cleanedData[key];
        }
      });
      return cleanedData;
  }
  
  async function fetchRecordsFiltered(tableId, filter = {}) {
    if (!tokenInfo) { throw new Error("API not initialized."); }
    const filterString = encodeURIComponent(JSON.stringify(filter));
    if (!document.referrer) { throw new Error("Cannot determine Grist API origin."); }
    
    const gristOrigin = new URL(document.referrer).origin;
    const apiPath = new URL(tokenInfo.baseUrl).pathname;
    const url = `${gristOrigin}${apiPath}/tables/${tableId}/records?filter=${filterString}&auth=${tokenInfo.token}`;

    console.log(`Fetching from API: ${url}`);
    const response = await fetch(url);

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`API Error Response for ${tableId}:`, errorText);
      throw new Error(`API Error (${response.status}) while fetching '${tableId}'.`);
    }
    const data = await response.json();
    return data.records;
  }

  async function cloneRelatedRecords(options) {
      const { parentTable, childTable, sourceParentId, newParentId, parentLinkColumnId, childLinkColumnId } = options;
      const childrenFilter = { [parentLinkColumnId]: [sourceParentId] };
      const childrenToClone = await fetchRecordsFiltered(parentTable, childrenFilter);

      if (childrenToClone.length === 0) {
        console.log(`No records found in ${parentTable} for parent ID ${sourceParentId}.`);
        return;
      }
      setUIState('processing', `Cloning ${childrenToClone.length} ${parentTable} records...`);

      const oldChildIds = childrenToClone.map(c => c.id);
      const newChildrenData = childrenToClone.map(c => {
          const data = cleanRecordData(c.fields);
          data[parentLinkColumnId] = newParentId;
          return data;
      });

      const newChildIds = await addRecords(parentTable, newChildrenData);
      if (newChildIds.length === 0) {
        console.warn(`Failed to create new records in ${parentTable}. Aborting grandchild clone.`);
        return;
      }

      if (!childTable || !childLinkColumnId) return;
      const oldToNewChildIdMap = new Map(oldChildIds.map((oldId, i) => [oldId, newChildIds[i]]));
      const grandchildrenFilter = { [childLinkColumnId]: oldChildIds };
      const grandchildrenToClone = await fetchRecordsFiltered(childTable, grandchildrenFilter);

      if (grandchildrenToClone.length === 0) return;
      setUIState('processing', `Cloning ${grandchildrenToClone.length} ${childTable} records...`);
      const newGrandchildrenData = grandchildrenToClone.map(gc => {
          const newParentIdForGrandchild = oldToNewChildIdMap.get(gc.fields[childLinkColumnId]);
          if (!newParentIdForGrandchild) return null;
          const data = cleanRecordData(gc.fields);
          data[childLinkColumnId] = newParentIdForGrandchild;
          return data;
      }).filter(Boolean);

      if (newGrandchildrenData.length > 0) {
        await addRecords(childTable, newGrandchildrenData);
      }
  }

  async function duplicateSelectedEvent() {
    try {
      if (!tokenInfo) { throw new Error("Widget is not ready."); }
      
      setUIState('processing', 'Preparing source event...');
      const sourceEventFromOnRecord = lastSelectedRecord;
      if (!sourceEventFromOnRecord || !sourceEventFromOnRecord.id) {
          throw new Error(`No event is selected.`);
      }
      const sourceEventId = sourceEventFromOnRecord.id;
      const sourceEventNameForMessage = sourceEventFromOnRecord.Name || 'Unknown';

      setUIState('processing', 'Fetching full source event data...');
      const sourceEventRecords = await fetchRecordsFiltered(config.tables.EVENTS, { id: [sourceEventId] });
      
      if (!sourceEventRecords || sourceEventRecords.length === 0) {
        throw new Error(`Could not fetch the source event (ID: ${sourceEventId}).`);
      }
      const sourceEventFields = sourceEventRecords[0].fields;
      
      setUIState('processing', 'Loading periods...');
      const periodsRecords = await fetchRecordsFiltered(config.tables.PERIODS, {});
      const periods = periodsRecords.map(p => ({id: p.id, text: p.fields.Name}));
      if (periods.length === 0) throw new Error('No Periods found.');

      populateSelector('period-select', periods);
      setUIState('selectingPeriod');
      const targetPeriodId = await new Promise(resolve => { activeProcess.resolvePeriod = resolve; });

      if (!targetPeriodId) { cancelProcess(); return; }

      const targetPeriod = periods.find(p => p.id === targetPeriodId);
      let targetYear = new Date().getFullYear();
      if (targetPeriod?.text) {
        const yearMatch = targetPeriod.text.match(/(\d{4})/);
        if (yearMatch) targetYear = parseInt(yearMatch[1], 10);
      }

      setUIState('processing', 'Cloning main event...');
      const newEventData = cleanRecordData(sourceEventFields);
      newEventData.Name = `COPY OF ${sourceEventFields.Name || 'Event'}`;
      newEventData.Period = targetPeriodId;
      newEventData.EventStatus = 1;
      newEventData.Notes = null;
      newEventData.DateStart = adjustDateToTargetYear(sourceEventFields.DateStart, targetYear);
      newEventData.DateEnd = adjustDateToTargetYear(sourceEventFields.DateEnd, targetYear);

      const newEventIds = await addRecords(config.tables.EVENTS, [newEventData]);
      const newEventId = newEventIds[0];

      await cloneRelatedRecords({
          parentTable: config.tables.EXPENSES, childTable: config.tables.EXPENSE_DETAILS,
          sourceParentId: sourceEventId, newParentId: newEventId,
          parentLinkColumnId: config.columnIds.EVENT_LINK,
          childLinkColumnId: config.columnIds.EXPENSE_LINK
      });

      await cloneRelatedRecords({
          parentTable: config.tables.REVENUES, childTable: config.tables.REVENUE_DETAILS,
          sourceParentId: sourceEventId, newParentId: newEventId,
          parentLinkColumnId: config.columnIds.EVENT_LINK,
          childLinkColumnId: config.columnIds.REVENUE_LINK
      });

      setUIState('success', `Event '${sourceEventNameForMessage}' duplicated successfully!`);
    } catch (err) {
      console.error('RapidShade duplication error', err);
      setUIState('error', `Error: ${err.message || err}`);
    }
  }

  async function initializeWidget() {
    try {
      console.log('Initializing widget and fetching API token...');
      tokenInfo = await grist.docApi.getAccessToken({ readOnly: false });
      
      console.log('Widget is ready.');
      grist.onRecord(record => {
        lastSelectedRecord = record;
        if (record?.id) {
            setUIState('selection', `[${record.id}] ${record.Name}`);
        } else {
          setUIState('initial');
        }
      });
    } catch (err) {
      console.error('Failed to initialize widget:', err);
      setUIState('error', `Initialization failed: ${err.message}`);
    }
  }
  
  grist.ready({ requiredAccess: 'full', table: config.tables.EVENTS });
  initializeWidget();

  document.getElementById('start-duplication').addEventListener('click', duplicateSelectedEvent);

  async function addRecords(tableName, records) {
    if (!records?.length) return [];
    const actions = records.map(record => ['AddRecord', tableName, null, record]);
    const results = await grist.docApi.applyUserActions(actions);
    return (results?.retValues || []).map(r => r?.id || r).filter(Boolean);
  }
  function adjustDateToTargetYear(sourceDate, targetPeriodYear) {
    if (!sourceDate || !targetPeriodYear) return sourceDate;
    try {
      const date = new Date(typeof sourceDate === 'number' ? sourceDate * 1000 : sourceDate);
      if (isNaN(date.getTime())) return date;
      date.setFullYear(targetPeriodYear);
      return date.getTime() / 1000;
    } catch (e) { return sourceDate; }
  }
  function cancelProcess() {
    if (activeProcess.resolvePeriod) activeProcess.resolvePeriod(null);
    setUIState('selection', activeProcess.sourceEventName);
  }
  document.getElementById('confirm-duplication').addEventListener('click', () => {
    if (activeProcess.resolvePeriod) activeProcess.resolvePeriod(parseInt(document.getElementById('period-select').value, 10));
  });
  document.getElementById('cancel-duplication').addEventListener('click', cancelProcess);
  function populateSelector(selectId, options) {
    const sel = document.getElementById(selectId);
    sel.innerHTML = '';
    options.forEach(opt => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.id;
      optionEl.textContent = opt.text;
      sel.appendChild(optionEl);
    });
  }
</script>
</body>
</html>

