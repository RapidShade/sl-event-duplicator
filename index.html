<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Duplicate Event Widget</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <style>
    /*
      Basic widget styling:
      - Centered container
      - Spinner animation during processing
      - `.hidden` class to toggle visibility
    */
    body {
      font-family: sans-serif;
      padding: 1rem;
      text-align: center;
      color: #333;
      background-color: #f9f9f9;
    }
    #widget-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    .hidden { display: none !important; }
    #loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    #period-selector-container {
      padding: 1rem;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: white;
    }
    select, button {
      padding: 8px 12px;
      margin-top: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    button {
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
    }
    #status {
      margin-top: 1rem;
      font-weight: bold;
    }
    .status-success { color: green; }
    .status-error   { color: red; }
    .status-info    { color: #555; }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>

<div id="widget-container">
  <!-- Initial idle state: instruct user to click Duplicate_Trigger -->
  <div id="initial-state">
    <h2>Duplicate Event Widget</h2>
    <p>Click the "Duplicate Event" button in your Events table to start.</p>
  </div>

  <!-- Processing state: spinner + message -->
  <div id="processing-state" class="hidden">
    <div id="loader"></div>
    <p id="processing-message">Working...</p>
  </div>

  <!-- Period selection state: dropdown + confirm/cancel buttons -->
  <div id="period-selector-container" class="hidden">
    <label for="period-select">Select Target Period:</label><br>
    <select id="period-select"></select><br>
    <button id="confirm-duplication">Confirm & Duplicate</button>
    <button id="cancel-duplication">Cancel</button>
  </div>

  <!-- Status message area for success/error/info -->
  <div id="status"></div>
</div>

<script>
  /**
   * RapidShade Duplicate Event Widget
   * Version: 2.2 (Corrected source record fetching)
   * Uses correct grist.docApi.applyUserActions() instead of addRecords()
   */
  console.log("RapidShade: Widget version 2.2 (Corrected source record fetching)");

  // --- Configuration: match Grist table names and trigger column ---
  const config = {
    tables: {
      EVENTS:                 "Events",
      PERIODS:                "Periods",
      PROJECTED_BUDGETS:      "ProjectedBudgets",
      EXPENSES:               "Expenses",
      EXPENSE_DETAILS:        "ExpenseDetails",
      REVENUES:               "Revenues",
      REVENUE_DETAILS:        "RevenueDetails",
      PERIOD_BUDGET_VERSIONS: "PeriodBudgetVersions",
    },
    triggerColumn: "Duplicate_Trigger"
  };

  let resolvePeriodSelection = null;

  // --- UI Control Functions ---
  function setUIState(state, message = '') {
    document.getElementById('initial-state').classList.add('hidden');
    document.getElementById('processing-state').classList.add('hidden');
    document.getElementById('period-selector-container').classList.add('hidden');
    document.getElementById('status').textContent = '';

    if (state === 'initial') {
      document.getElementById('initial-state').classList.remove('hidden');
    } else if (state === 'processing') {
      document.getElementById('processing-state').classList.remove('hidden');
      document.getElementById('processing-message').textContent = message;
    } else if (state === 'selecting') {
      document.getElementById('period-selector-container').classList.remove('hidden');
    } else if (['success', 'error', 'info'].includes(state)) {
      const el = document.getElementById('status');
      el.textContent = message;
      el.className = `status-${state}`;
      document.getElementById('initial-state').classList.remove('hidden');
    }
  }

  // The normalizeTableData function is no longer needed with the new approach
  // of fetching records directly.

  async function getPeriodsData() {
    // We can directly use the result of fetchTable, which is an array of records.
    return await grist.docApi.fetchTable(config.tables.PERIODS);
  }

  async function promptForPeriod(periods) {
    if (!Array.isArray(periods) || periods.length === 0) return null;
    const sel = document.getElementById('period-select');
    sel.innerHTML = '';
    periods.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.Name; // Fields are direct properties
      sel.appendChild(opt);
    });
    setUIState('selecting');
    return new Promise(resolve => resolvePeriodSelection = resolve);
  }

  document.getElementById('confirm-duplication').addEventListener('click', () => {
    if (resolvePeriodSelection) resolvePeriodSelection(parseInt(document.getElementById('period-select').value, 10));
  });
  document.getElementById('cancel-duplication').addEventListener('click', () => {
    if (resolvePeriodSelection) resolvePeriodSelection(null);
    setUIState('initial');
  });

  /**
   * Helper function to adjust dates to the target period's year
   */
  function adjustDateToTargetYear(sourceDate, targetPeriodYear) {
    if (!sourceDate || !targetPeriodYear) return sourceDate;
    
    try {
      const date = new Date(sourceDate);
      if (isNaN(date.getTime())) return sourceDate; // Invalid date, return as-is
      
      // Keep the same month and day, but change the year to target period's year
      date.setFullYear(targetPeriodYear);
      return date.toISOString().split('T')[0]; // Return as YYYY-MM-DD format
    } catch (e) {
      console.log("RapidShade: Error adjusting date:", e);
      return sourceDate; // Return original if there's an error
    }
  }

  /**
   * Helper function to add records using applyUserActions
   */
  async function addRecords(tableName, records) {
    if (!records || records.length === 0) return [];
    
    // Convert records to the format expected by AddRecord action
    const actions = records.map(record => [
      'AddRecord',
      tableName,
      null, // let Grist assign the ID
      record
    ]);
    
    // Apply all actions and get the results
    const results = await grist.docApi.applyUserActions(actions);
    
    // The result from applyUserActions is an object with retValues array
    // Each AddRecord action returns the new record ID
    if (results && results.retValues && Array.isArray(results.retValues)) {
      return results.retValues;
    }
    
    // Fallback: if results is directly an array
    if (Array.isArray(results)) {
      return results;
    }
    
    // If single result, wrap in array
    return [results];
  }

  /**
   * Main duplication workflow
   */
  async function duplicateEvent() {
    try {
      const sourceEvent = await grist.view.fetchSelectedRecord();
      if (!sourceEvent || !sourceEvent.id) {
        console.log("RapidShade: No event selected for duplication.");
        // We can optionally show a message to the user here.
        return;
      }
      
      const sourceEventId = sourceEvent.id;
      console.log("RapidShade: Duplicating Event ID:", sourceEventId);
      console.log("RapidShade: Source event data:", sourceEvent);
      
      setUIState('processing', 'Loading periods...');
      const periods = await getPeriodsData();
      const targetPeriodId = await promptForPeriod(periods);
      if (!targetPeriodId) return setUIState('info', 'Duplication canceled.');

      const targetPeriod = periods.find(p => p.id === targetPeriodId);
      const targetPeriodName = targetPeriod ? targetPeriod.Name : '';
      
      let targetYear = new Date().getFullYear();
      if (targetPeriodName) {
        const yearMatch = targetPeriodName.match(/(\d{4})/);
        if (yearMatch) {
          targetYear = parseInt(yearMatch[1], 10);
        }
      }
      
      console.log("RapidShade: Target period:", targetPeriodName, "Target year:", targetYear);

      setUIState('processing', 'Creating new Event...');
      
      // Dynamically copy all fields from the source event
      const newEventData = { ...sourceEvent };
      delete newEventData.id; // Remove the original ID

      // Set/override specific fields for the new event
      newEventData.Name = `${sourceEvent.Name || 'Unknown'} (Copy)`;
      newEventData.Period = targetPeriodId;
      newEventData.EventStatus = 1; // Assuming '1' is a default status for new events
      newEventData.Notes = null;
      newEventData.DateStart = adjustDateToTargetYear(sourceEvent.DateStart, targetYear);
      newEventData.DateEnd = adjustDateToTargetYear(sourceEvent.DateEnd, targetYear);
      
      console.log("RapidShade: New event data:", newEventData);
      
      const newEventIds = await addRecords(config.tables.EVENTS, [newEventData]);
      const newEventId = newEventIds[0];
      
      console.log("RapidShade: New event created with ID:", newEventId);

      // --- Clone Child Records ---
      // The logic for cloning children remains similar, but we'll fetch them 
      // using the correct sourceEventId and ensure we're using direct field access.

      setUIState('processing', 'Cloning budget version...');
      const versions = await grist.docApi.fetchTable(config.tables.PERIOD_BUDGET_VERSIONS, { Event: [sourceEventId] });
      const activeVersion = versions.find(v => v.IsActive) || versions.sort((a, b) => new Date(b.Date) - new Date(a.Date))[0];
      if (activeVersion) {
          const newVersionData = {...activeVersion, Event: newEventId};
          delete newVersionData.id;
          await addRecords(config.tables.PERIOD_BUDGET_VERSIONS, [newVersionData]);
      }
      
      setUIState('processing', 'Cloning projected budgets...');
      const projectedBudgets = await grist.docApi.fetchTable(config.tables.PROJECTED_BUDGETS, { Event: [sourceEventId] });
      const newProjectedBudgets = projectedBudgets.map(pb => {
        const newData = { ...pb, Event: newEventId };
        delete newData.id;
        return newData;
      });
      if (newProjectedBudgets.length) await addRecords(config.tables.PROJECTED_BUDGETS, newProjectedBudgets);

      setUIState('processing', 'Cloning expenses...');
      const expenses = await grist.docApi.fetchTable(config.tables.EXPENSES, { Event: [sourceEventId] });
      for (const exp of expenses) {
        const newExpenseData = { ...exp, Event: newEventId, Notes: null };
        delete newExpenseData.id;
        const newExpenseIds = await addRecords(config.tables.EXPENSES, [newExpenseData]);
        const newExpenseId = newExpenseIds[0];
        
        const expenseDetails = await grist.docApi.fetchTable(config.tables.EXPENSE_DETAILS, { Expense: [exp.id] });
        const newExpenseDetails = expenseDetails.map(d => {
            const newData = { ...d, Expense: newExpenseId, Event: newEventId };
            delete newData.id;
            return newData;
        });
        if (newExpenseDetails.length) await addRecords(config.tables.EXPENSE_DETAILS, newExpenseDetails);
      }

      setUIState('processing', 'Cloning revenues...');
      const revenues = await grist.docApi.fetchTable(config.tables.REVENUES, { Event: [sourceEventId] });
      for (const rev of revenues) {
        const newRevenueData = { ...rev, Event: newEventId, Notes: null };
        delete newRevenueData.id;
        const newRevenueIds = await addRecords(config.tables.REVENUES, [newRevenueData]);
        const newRevenueId = newRevenueIds[0];
        
        const revenueDetails = await grist.docApi.fetchTable(config.tables.REVENUE_DETAILS, { Revenue: [rev.id] });
        const newRevenueDetails = revenueDetails.map(d => {
            const newData = { ...d, Revenue: newRevenueId, Event: newEventId };
            delete newData.id;
            return newData;
        });
        if (newRevenueDetails.length) await addRecords(config.tables.REVENUE_DETAILS, newRevenueDetails);
      }

      setUIState('success', `Event '${sourceEvent.Name || 'Unknown'}' duplicated successfully!`);
    } catch (err) {
      console.error('RapidShade duplication error', err);
      setUIState('error', `Error: ${err.message}`);
    }
  }

  // --- Initialization ---
  grist.ready({
    requiredAccess: 'full',
    columns: [config.triggerColumn]
  });

  grist.onRecord(duplicateEvent);
</script>
</body>
</html>
