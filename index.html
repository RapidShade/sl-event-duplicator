<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Duplicate Event Widget</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <style>
        /* Basic widget styling */
        body {
            font-family: sans-serif;
            padding: 1rem;
            text-align: center;
            color: #333;
            background-color: #f9f9f9;
        }
        #widget-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        .hidden { display: none !important; }
        #loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        #period-selector-container {
            padding: 1rem;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: white;
        }
        select,
        button {
            padding: 8px 12px;
            margin-top: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
        }
        #status {
            margin-top: 1rem;
            font-weight: bold;
        }
        .status-success { color: green; }
        .status-error { color: red; }
        .status-info { color: #555; }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div id="widget-container">
    <!-- Initial prompt state -->
    <div id="initial-state">
        <h2>Duplicate Event Widget</h2>
        <p>Ready. Click the "Duplicate Event" button in any row in the Events table to begin.</p>
    </div>

    <!-- Processing spinner state -->
    <div id="processing-state" class="hidden">
        <div id="loader"></div>
        <p id="processing-message">Working...</p>
    </div>

    <!-- Period selection dropdown -->
    <div id="period-selector-container" class="hidden">
        <label for="period-select">Select Target Period:</label><br>
        <select id="period-select"></select><br>
        <button id="confirm-duplication">Confirm & Duplicate</button>
        <button id="cancel-duplication">Cancel</button>
    </div>

    <!-- Status message area -->
    <div id="status"></div>
</div>

<script>
    /**
     * RapidShade Duplicate Event Widget
     * Version: 0.7
     * This widget duplicates an Event and its related records
     * across Events, PeriodBudgetVersions, ProjectedBudgets,
     * Expenses (+ExpenseDetails), Revenues (+RevenueDetails).
     */

    // Log widget version for debugging
    console.log("RapidShade: Widget version 0.7");

    // --- CONFIGURATION ---
    // Ensure these match exactly your Grist tables and column IDs
    const config = {
        tables: {
            EVENTS: "Events",
            PERIODS: "Periods",
            PROJECTED_BUDGETS: "ProjectedBudgets",
            EXPENSES: "Expenses",
            EXPENSE_DETAILS: "ExpenseDetails",
            REVENUES: "Revenues",
            REVENUE_DETAILS: "RevenueDetails",
            PERIOD_BUDGET_VERSIONS: "PeriodBudgetVersions",
        },
        // The column on the Events table (button or checkbox) that triggers the widget
        triggerColumn: "Duplicate_Trigger",
    };

    // In-memory storage for fetched static tables
    let allTables = {};

    // Resolver for period selection promise
    let resolvePeriodSelection = null;

    /**
     * setUIState: Manages visibility of widget sections
     * states: 'initial', 'processing', 'selecting', 'success', 'error', 'info'
     */
    function setUIState(state, message = '') {
        document.getElementById('initial-state').classList.add('hidden');
        document.getElementById('processing-state').classList.add('hidden');
        document.getElementById('period-selector-container').classList.add('hidden');
        document.getElementById('status').textContent = '';

        if (state === 'initial') {
            document.getElementById('initial-state').classList.remove('hidden');
        } else if (state === 'processing') {
            document.getElementById('processing-state').classList.remove('hidden');
            document.getElementById('processing-message').textContent = message;
        } else if (state === 'selecting') {
            document.getElementById('period-selector-container').classList.remove('hidden');
        } else if (['success', 'error', 'info'].includes(state)) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-${state}`;
            document.getElementById('initial-state').classList.remove('hidden');
        }
    }

    /**
     * normalizeTableData
     * Converts fetchTable response into array of {id, fields} records
     * Supports array-of-records, {records: [...]}, or columnar format
     */
    function normalizeTableData(tableData) {
        if (Array.isArray(tableData)) {
            return tableData;
        }
        if (tableData.records) {
            return tableData.records;
        }
        // Columnar format
        const keys = Object.keys(tableData).filter(k => Array.isArray(tableData[k]));
        const length = tableData[keys[0]]?.length || 0;
        const records = [];
        for (let i = 0; i < length; i++) {
            const rec = { id: null, fields: {} };
            keys.forEach(k => {
                if (k === 'id') {
                    rec.id = tableData[k][i];
                } else {
                    rec.fields[k] = tableData[k][i];
                }
            });
            records.push(rec);
        }
        return records;
    }

    /**
     * getPeriodsData
     * Fetches the latest Periods table data on demand
     */
    async function getPeriodsData() {
        console.log("RapidShade: Fetching periods table via API");
        const tableData = await grist.docApi.fetchTable(config.tables.PERIODS);
        console.log("RapidShade: Raw periods data:", tableData);
        const records = normalizeTableData(tableData);
        console.log("RapidShade: Normalized periods records:", records);
        return records;
    }

    /**
     * promptForPeriod
     * Renders dropdown and returns selected Period id
     */
    async function promptForPeriod(periods) {
        if (!Array.isArray(periods) || periods.length === 0) {
            console.log("RapidShade: No periods data available to prompt");
            return null;
        }
        const selectEl = document.getElementById('period-select');
        selectEl.innerHTML = '';
        periods.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = p.fields.Name;
            selectEl.appendChild(option);
        });
        setUIState('selecting');
        return new Promise(resolve => { resolvePeriodSelection = resolve; });
    }

    // Confirm & Cancel handlers
    document.getElementById('confirm-duplication').addEventListener('click', () => {
        const val = parseInt(document.getElementById('period-select').value, 10);
        console.log(`RapidShade: Period selected ${val}`);
        resolvePeriodSelection(val);
    });
    document.getElementById('cancel-duplication').addEventListener('click', () => {
        console.log("RapidShade: Duplication cancelled by user");
        resolvePeriodSelection(null);
        setUIState('initial');
    });

    /**
     * duplicateEvent
     * Core duplication logic triggered per-row.
     */
    async function duplicateEvent(sourceEvent) {
        if (!sourceEvent) { return; }
        console.log(`RapidShade: Starting duplication for event ${sourceEvent.id}`);
        try {
            // 1. Prompt for target Period
            setUIState('processing', 'Fetching period data...');
            const periods = await getPeriodsData();
            const targetPeriodId = await promptForPeriod(periods);
            if (!targetPeriodId) {
                setUIState('info', 'Duplication cancelled.');
                return;
            }

            // 2. Create new Event record via API
            setUIState('processing', 'Creating new event...');
            console.log(`RapidShade: Creating new Event under Period ${targetPeriodId}`);
            const [newEventId] = await grist.docApi.addRecords(config.tables.EVENTS, [{
                Name: `${sourceEvent.Name} (Copy)`,
                Sport: sourceEvent.Sport,
                Period: targetPeriodId,
                LocationScope: sourceEvent.LocationScope,
                EventStatus: 1,
                EventType: sourceEvent.EventType,
                DateStart: null,
                DateEnd: null,
                Notes: null,
            }]);

            // 3. Duplicate PeriodBudgetVersions (active or latest)
            setUIState('processing', 'Duplicating budget version...');
            console.log(`RapidShade: Copying PeriodBudgetVersions for event ${sourceEvent.id}`);
            const pbvs = allTables.PeriodBudgetVersions.filter(pb => pb.fields.Event === sourceEvent.id);
            let srcPBV = pbvs.find(pb => pb.fields.IsActive)
                || pbvs.sort((a, b) => new Date(b.fields.Created) - new Date(a.fields.Created))[0];
            if (srcPBV) {
                const recordData = {};
                Object.entries(srcPBV.fields).forEach(([col, val]) => {
                    if (col !== 'id' && col !== 'Event') {
                        recordData[col] = val;
                    }
                });
                recordData.Event = newEventId;
                console.log(`RapidShade: Adding PeriodBudgetVersions copy ${srcPBV.id}`);
                await grist.docApi.addRecords(
                    config.tables.PERIOD_BUDGET_VERSIONS,
                    [recordData]
                );
            }

            // 4. Duplicate ProjectedBudgets
            setUIState('processing', 'Duplicating projected budgets...');
            console.log(`RapidShade: Copying ProjectedBudgets for event ${sourceEvent.id}`);
            const srcPB = allTables.ProjectedBudgets.filter(pb => pb.fields.Event === sourceEvent.id);
            if (srcPB.length) {
                const pbData = srcPB.map(pb => ({
                    Event: newEventId,
                    Sport: pb.fields.Sport,
                    ProjectedExpenses: pb.fields.ProjectedExpenses,
                    ProjectedRevenues: pb.fields.ProjectedRevenues,
                }));
                await grist.docApi.addRecords(config.tables.PROJECTED_BUDGETS, pbData);
            }

            // 5. Duplicate Expenses + Details
            setUIState('processing', 'Duplicating expenses...');
            console.log(`RapidShade: Copying Expenses and ExpenseDetails for event ${sourceEvent.id}`);
            const srcExp = allTables.Expenses.filter(e => e.fields.Event === sourceEvent.id);
            for (const exp of srcExp) {
                const [newExpId] = await grist.docApi.addRecords(config.tables.EXPENSES, [{
                    Event: newEventId,
                    Category: exp.fields.Category,
                    Budget: exp.fields.Budget,
                    Projected: exp.fields.Projected,
                    Actual: 0,
                    Notes: null,
                }]);
                console.log(`RapidShade: Created expense ${newExpId}`);
                const expDetails = allTables.ExpenseDetails.filter(d => d.fields.Expense === exp.id);
                if (expDetails.length) {
                    const detData = expDetails.map(d => ({
                        Expense: newExpId,
                        Event: newEventId,
                        Supplier: d.fields.Supplier,
                        Description: d.fields.Description,
                        Budget: d.fields.Budget,
                        Actual: 0,
                        Notes: null,
                    }));
                    await grist.docApi.addRecords(config.tables.EXPENSE_DETAILS, detData);
                }
            }

            // 6. Duplicate Revenues + Details
            setUIState('processing', 'Duplicating revenues...');
            console.log(`RapidShade: Copying Revenues and RevenueDetails for event ${sourceEvent.id}`);
            const srcRev = allTables.Revenues.filter(r => r.fields.Event === sourceEvent.id);
            for (const rev of srcRev) {
                const [newRevId] = await grist.docApi.addRecords(config.tables.REVENUES, [{
                    Event: newEventId,
                    Category: rev.fields.Category,
                    Budget: rev.fields.Budget,
                    Projected: rev.fields.Projected,
                    Actual: 0,
                    Notes: null,
                }]);
                console.log(`RapidShade: Created revenue ${newRevId}`);
                const revDetails = allTables.RevenueDetails.filter(d => d.fields.Revenue === rev.id);
                if (revDetails.length) {
                    const rdData = revDetails.map(d => ({
                        Revenue: newRevId,
                        Event: newEventId,
                        Supplier: d.fields.Supplier,
                        Description: d.fields.Description,
                        Budget: d.fields.Budget,
                        Actual: 0,
                        Notes: null,
                    }));
                    await grist.docApi.addRecords(config.tables.REVENUE_DETAILS, rdData);
                }
            }

            // Success
            setUIState('success', `Event '${sourceEvent.Name}' duplicated successfully!`);
            console.log("RapidShade: Duplication complete");
        } catch (err) {
            console.error("RapidShade: Error during duplication:", err);
            setUIState('error', `Error during duplication: ${err.message}`);
        }
    }

    // Initialize widget: request required access & tables/column
    grist.ready({
        requiredAccess: 'full',
        columns: [config.triggerColumn],
        tables: Object.values(config.tables)
    });

    // Fetch static tables once, normalize, then bind duplicateEvent
    Promise.all([
        grist.docApi.fetchTable(config.tables.EVENTS),
        grist.docApi.fetchTable(config.tables.PERIOD_BUDGET_VERSIONS),
        grist.docApi.fetchTable(config.tables.PROJECTED_BUDGETS),
        grist.docApi.fetchTable(config.tables.EXPENSES),
        grist.docApi.fetchTable(config.tables.EXPENSE_DETAILS),
        grist.docApi.fetchTable(config.tables.REVENUES),
        grist.docApi.fetchTable(config.tables.REVENUE_DETAILS),
    ]).then(([evts, pbvs, pbs, exps, exds, revs, revds]) => {
        allTables = {
            Events: normalizeTableData(evts),
            PeriodBudgetVersions: normalizeTableData(pbvs),
            ProjectedBudgets: normalizeTableData(pbs),
            Expenses: normalizeTableData(exps),
            ExpenseDetails: normalizeTableData(exds),
            Revenues: normalizeTableData(revs),
            RevenueDetails: normalizeTableData(revds),
        };
        console.log("RapidShade: Loaded static tables into memory");
        grist.onRecord(duplicateEvent);
    }).catch(err => {
        console.error("RapidShade: Failed to load initial data:", err);
        setUIState('error', 'Failed to load initial data. Check table/column names.');
    });
</script>
</body>
</html>
