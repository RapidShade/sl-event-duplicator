<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Duplicate Event Widget</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <style>
    /*
      Basic widget styling:
      - Centered container
      - Spinner animation during processing
      - `.hidden` class to toggle visibility
    */
    body {
      font-family: sans-serif;
      padding: 1rem;
      text-align: center;
      color: #333;
      background-color: #f9f9f9;
    }
    #widget-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    .hidden { display: none !important; }
    #loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    #period-selector-container {
      padding: 1rem;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: white;
    }
    select, button {
      padding: 8px 12px;
      margin-top: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    button {
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
    }
    #status {
      margin-top: 1rem;
      font-weight: bold;
    }
    .status-success { color: green; }
    .status-error   { color: red; }
    .status-info    { color: #555; }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>

<div id="widget-container">
  <!-- Initial idle state: instruct user to click Duplicate_Trigger -->
  <div id="initial-state">
    <h2>Duplicate Event Widget</h2>
    <p>Click the "Duplicate Event" button in your Events table to start.</p>
  </div>

  <!-- Processing state: spinner + message -->
  <div id="processing-state" class="hidden">
    <div id="loader"></div>
    <p id="processing-message">Working...</p>
  </div>

  <!-- Period selection state: dropdown + confirm/cancel buttons -->
  <div id="period-selector-container" class="hidden">
    <label for="period-select">Select Target Period:</label><br>
    <select id="period-select"></select><br>
    <button id="confirm-duplication">Confirm & Duplicate</button>
    <button id="cancel-duplication">Cancel</button>
  </div>

  <!-- Status message area for success/error/info -->
  <div id="status"></div>
</div>

<script>
  /**
   * RapidShade Duplicate Event Widget
   * Version: 1.5
   * Clones an Event record and its related data across tables:
   *   - PeriodBudgetVersions (active or latest)
   *   - ProjectedBudgets
   *   - Expenses + ExpenseDetails
   *   - Revenues + RevenueDetails
   *
   * Highlights:
   * 1. User clicks Duplicate_Trigger in Events row
   * 2. Widget prompts for target Period
   * 3. Creates new Event record
   * 4. Copies related records with initial values
   * 5. Provides status updates and error handling
   */
  console.log("RapidShade: Widget version 1.5");

  // --- Configuration: match Grist table names and trigger column ---
  const config = {
    tables: {
      EVENTS:                "Events",
      PERIODS:               "Periods",
      PROJECTED_BUDGETS:     "ProjectedBudgets",
      EXPENSES:              "Expenses",
      EXPENSE_DETAILS:       "ExpenseDetails",
      REVENUES:              "Revenues",
      REVENUE_DETAILS:       "RevenueDetails",
      PERIOD_BUDGET_VERSIONS: "PeriodBudgetVersions",
    },
    triggerColumn: "Duplicate_Trigger"
  };

  // In-memory cache for static tables fetched at init
  let allTables = {};
  // Promise resolver for period selection dialog
  let resolvePeriodSelection = null;

  /**
   * addRecords(table, dataArr)
   * ----------------------------
   * Batch-adds records via applyUserActions.
   * Each action: ["AddRecord", table, { column_values: {...} }]
   * @returns {Array<number>} New record IDs
   */
  async function addRecords(table, dataArr) {
    const actions = dataArr.map(data => [
      "AddRecord",
      table,
      { column_values: data }
    ]);
    // applyUserActions expects (docIndex, actions[])
    return await grist.docApi.applyUserActions(0, actions);
  }

  /**
   * setUIState(state, message)
   * ---------------------------
   * Controls which section is visible:
   * - 'initial': prompt
   * - 'processing': spinner + message
   * - 'selecting': period dropdown
   * - 'success'/'error'/'info': status line + back to initial
   */
  function setUIState(state, message = '') {
    // Hide all sections
    document.getElementById('initial-state').classList.add('hidden');
    document.getElementById('processing-state').classList.add('hidden');
    document.getElementById('period-selector-container').classList.add('hidden');
    document.getElementById('status').textContent = '';

    // Show relevant UI
    if (state === 'initial') {
      document.getElementById('initial-state').classList.remove('hidden');
    } else if (state === 'processing') {
      document.getElementById('processing-state').classList.remove('hidden');
      document.getElementById('processing-message').textContent = message;
    } else if (state === 'selecting') {
      document.getElementById('period-selector-container').classList.remove('hidden');
    } else if (['success', 'error', 'info'].includes(state)) {
      const el = document.getElementById('status');
      el.textContent = message;
      el.className = `status-${state}`;
      document.getElementById('initial-state').classList.remove('hidden');
    }
  }

  /**
   * normalizeTableData(tableData)
   * ------------------------------
   * Converts various fetchTable responses into array of {id, fields}.
   */
  function normalizeTableData(tableData) {
    if (Array.isArray(tableData)) return tableData;
    if (tableData.records) return tableData.records;
    // Columnar format
    const keys = Object.keys(tableData).filter(k => Array.isArray(tableData[k]));
    const len = tableData[keys[0]].length;
    const recs = [];
    for (let i = 0; i < len; i++) {
      const rec = { id: null, fields: {} };
      keys.forEach(k => {
        if (k === 'id') rec.id = tableData[k][i];
        else rec.fields[k] = tableData[k][i];
      });
      recs.push(rec);
    }
    return recs;
  }

  /**
   * getPeriodsData()
   * -----------------
   * Fetches live Periods table and normalizes it.
   */
  async function getPeriodsData() {
    console.log("RapidShade: Fetching Periods table");
    const raw = await grist.docApi.fetchTable(config.tables.PERIODS);
    return normalizeTableData(raw);
  }

  /**
   * promptForPeriod(periods)
   * ------------------------
   * Renders dropdown and returns chosen period ID.
   */
  async function promptForPeriod(periods) {
    if (!Array.isArray(periods) || periods.length === 0) {
      console.log("RapidShade: No periods to select");
      return null;
    }
    const sel = document.getElementById('period-select');
    sel.innerHTML = '';
    periods.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.fields.Name;
      sel.appendChild(opt);
    });
    setUIState('selecting');
    return new Promise(resolve => resolvePeriodSelection = resolve);
  }

  // Confirm/Cancel button event listeners
  document.getElementById('confirm-duplication').addEventListener('click', () => {
    resolvePeriodSelection(parseInt(document.getElementById('period-select').value, 10));
  });
  document.getElementById('cancel-duplication').addEventListener('click', () => {
    resolvePeriodSelection(null);
    setUIState('initial');
  });

  /**
   * duplicateEvent(sourceEvent)
   * ---------------------------
   * Main duplication workflow:
   * 1. Prompt user for period
   * 2. Create new Event
   * 3. Clone PeriodBudgetVersions
   * 4. Clone ProjectedBudgets
   * 5. Clone Expenses + ExpenseDetails
   * 6. Clone Revenues + RevenueDetails
   */
  async function duplicateEvent(sourceEvent) {
    if (!sourceEvent) return;
    try {
      // Step 1: Select target period
      setUIState('processing', 'Loading periods...');
      const periods = await getPeriodsData();
      const chosen = await promptForPeriod(periods);
      if (!chosen) return setUIState('info', 'Duplication canceled');

      // Step 2: Create Event
      setUIState('processing', 'Creating new Event...');
      const [newEventId] = await addRecords(config.tables.EVENTS, [{
        Name:           `${sourceEvent.Name} (Copy)`,
        Sport:          sourceEvent.Sport,
        Period:         chosen,
        LocationScope:  sourceEvent.LocationScope,
        EventStatus:    1,
        EventType:      sourceEvent.EventType,
        DateStart:      null,
        DateEnd:        null,
        Notes:          null,
      }]);

      // Step 3: Clone PeriodBudgetVersions
      setUIState('processing', 'Cloning budget version...');
      const versions = allTables.PeriodBudgetVersions.filter(v => v.fields.Event === sourceEvent.id);
      const active = versions.find(v => v.fields.IsActive) || versions.sort((a,b)=>new Date(b.fields.Created)-new Date(a.fields.Created))[0];
      if (active) {
        const data = {};
        Object.entries(active.fields).forEach(([col,val]) => { if (col !== 'id' && col !== 'Event') data[col] = val; });
        data.Event = newEventId;
        await addRecords(config.tables.PERIOD_BUDGET_VERSIONS, [data]);
      }

      // Step 4: Clone ProjectedBudgets
      setUIState('processing', 'Cloning projected budgets...');
      const proj = allTables.ProjectedBudgets.filter(pb => pb.fields.Event === sourceEvent.id)
        .map(pb => ({ Event:newEventId, Sport:pb.fields.Sport, ProjectedExpenses:pb.fields.ProjectedExpenses, ProjectedRevenues:pb.fields.ProjectedRevenues }));
      if (proj.length) await addRecords(config.tables.PROJECTED_BUDGETS, proj);

      // Step 5: Clone Expenses + Details
      setUIState('processing', 'Cloning expenses...');
      for (const exp of allTables.Expenses.filter(e=>e.fields.Event===sourceEvent.id)) {
        const [newExp] = await addRecords(config.tables.EXPENSES, [{ Event:newEventId, Category:exp.fields.Category, Budget:exp.fields.Budget, Projected:exp.fields.Projected, Actual:0, Notes:null }]);
        const det = allTables.ExpenseDetails.filter(d=>d.fields.Expense===exp.id)
          .map(d=>({ Expense:newExp, Event:newEventId, Supplier:d.fields.Supplier, Description:d.fields.Description, Budget:d.fields.Budget, Actual:0, Notes:null }));
        if (det.length) await addRecords(config.tables.EXPENSE_DETAILS, det);
      }

      // Step 6: Clone Revenues + Details
      setUIState('processing', 'Cloning revenues...');
      for (const rev of allTables.Revenues.filter(r=>r.fields.Event===sourceEvent.id)) {
        const [newRev] = await addRecords(config.tables.REVENUES, [{ Event:newEventId, Category:rev.fields.Category, Budget:rev.fields.Budget, Projected:rev.fields.Projected, Actual:0, Notes:null }]);
        const revDet = allTables.RevenueDetails.filter(d=>d.fields.Revenue===rev.id)
          .map(d=>({ Revenue:newRev, Event:newEventId, Supplier:d.fields.Supplier, Description:d.fields.Description, Budget:d.fields.Budget, Actual:0, Notes:null }));
        if (revDet.length) await addRecords(config.tables.REVENUE_DETAILS, revDet);
      }

      // Done
      setUIState('success', `Event '${sourceEvent.Name}' duplicated successfully!`);
    } catch (err) {
      console.error('RapidShade duplication error', err);
      setUIState('error', `Error: ${err.message}`);
    }
  }

  // --- Initialization ---
  grist.ready({ requiredAccess: 'full', columns: [config.triggerColumn], tables: Object.values(config.tables) });
  Promise.all([
    grist.docApi.fetchTable(config.tables.EVENTS),
    grist.docApi.fetchTable(config.tables.PERIOD_BUDGET_VERSIONS),
    grist.docApi.fetchTable(config.tables.PROJECTED_BUDGETS),
    grist.docApi.fetchTable(config.tables.EXPENSES),
    grist.docApi.fetchTable(config.tables.EXPENSE_DETAILS),
    grist.docApi.fetchTable(config.tables.REVENUES),
    grist.docApi.fetchTable(config.tables.REVENUE_DETAILS)
  ]).then(([evts,pbvs,pbs,exps,exds,revs,rvds]) => {
    allTables = {
      Events: normalizeTableData(evts),
      PeriodBudgetVersions: normalizeTableData(pbvs),
      ProjectedBudgets: normalizeTableData(pbs),
      Expenses: normalizeTableData(exps),
      ExpenseDetails: normalizeTableData(exds),
      Revenues: normalizeTableData(revs),
      RevenueDetails: normalizeTableData(rvds)
    };
    grist.onRecord(duplicateEvent);
  }).catch(initErr => {
    console.error('RapidShade init error', initErr);
    setUIState('error', 'Initialization failed.');
  });
</script>
</body>
</html>
