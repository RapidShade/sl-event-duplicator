<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Duplicate Event Widget</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <style>
        /* Basic widget styling */
        body { font-family: sans-serif; padding: 1rem; text-align: center; color: #333; background-color: #f9f9f9; }
        #widget-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; }
        .hidden { display: none !important; }
        #loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
        #period-selector-container { padding: 1rem; border: 1px solid #ccc; border-radius: 8px; background-color: white; }
        select, button { padding: 8px 12px; margin-top: 10px; border-radius: 4px; border: 1px solid #ccc; }
        button { background-color: #4CAF50; color: white; cursor: pointer; }
        #status { margin-top: 1rem; font-weight: bold; }
        .status-success { color: green; }
        .status-error { color: red; }
        .status-info { color: #555; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
<div id="widget-container">
    <!-- Initial prompt state -->
    <div id="initial-state">
        <h2>Duplicate Event Widget</h2>
        <p>Ready. Click the "Duplicate Event" button in any row in the Events table to begin.</p>
    </div>

    <!-- Processing spinner state -->
    <div id="processing-state" class="hidden">
        <div id="loader"></div>
        <p id="processing-message">Working...</p>
    </div>

    <!-- Period selection dropdown -->
    <div id="period-selector-container" class="hidden">
        <label for="period-select">Select Target Period:</label><br>
        <select id="period-select"></select><br>
        <button id="confirm-duplication">Confirm & Duplicate</button>
        <button id="cancel-duplication">Cancel</button>
    </div>

    <!-- Status message area -->
    <div id="status"></div>
</div>

<script>
    // --- VERSION LOGGING ---
    // Logs the current widget version for debugging
    console.log("RapidShade: Widget version 0.5");

    // --- CONFIGURATION ---
    // Map Grist table names and trigger column
    const config = {
        tables: {
            EVENTS: "Events",
            PERIODS: "Periods",
            PROJECTED_BUDGETS: "ProjectedBudgets",
            EXPENSES: "Expenses",
            EXPENSE_DETAILS: "ExpenseDetails",
            REVENUES: "Revenues",
            REVENUE_DETAILS: "RevenueDetails",
            PERIOD_BUDGET_VERSIONS: "PeriodBudgetVersions",
        },
        triggerColumn: "Duplicate_Trigger",  // Column in Events table to listen for clicks
    };

    // Storage for fetched table data
    let allTables = {};
    let resolvePeriodSelection = null;

    /**
     * Updates the UI state: initial, processing, selecting, or final status.
     * @param {string} state - One of 'initial', 'processing', 'selecting', 'success', 'error', 'info'
     * @param {string} message - Optional status message
     */
    function setUIState(state, message = '') {
        document.getElementById('initial-state').classList.add('hidden');
        document.getElementById('processing-state').classList.add('hidden');
        document.getElementById('period-selector-container').classList.add('hidden');
        document.getElementById('status').textContent = '';
        if (state === 'initial') {
            document.getElementById('initial-state').classList.remove('hidden');
        } else if (state === 'processing') {
            document.getElementById('processing-state').classList.remove('hidden');
            document.getElementById('processing-message').textContent = message;
        } else if (state === 'selecting') {
            document.getElementById('period-selector-container').classList.remove('hidden');
        } else if (['success','error','info'].includes(state)) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-${state}`;
            document.getElementById('initial-state').classList.remove('hidden');
        }
    }

    /**
     * Converts fetched tableData into an array of {id, fields} records
     * Handles array-of-records, .records property, or columnar format
     * @param {object|array} tableData
     * @returns {array} records
     */
    function normalizeTableData(tableData) {
        if (Array.isArray(tableData)) {
            return tableData;
        }
        if (tableData.records) {
            return tableData.records;
        }
        // Columnar format: keys map to arrays of values
        const keys = Object.keys(tableData).filter(k => Array.isArray(tableData[k]));
        const length = tableData[keys[0]]?.length || 0;
        const records = [];
        for (let i = 0; i < length; i++) {
            const rec = { id: null, fields: {} };
            keys.forEach(k => {
                if (k === 'id') {
                    rec.id = tableData[k][i];
                } else {
                    rec.fields[k] = tableData[k][i];
                }
            });
            records.push(rec);
        }
        return records;
    }

    /**
     * Fetches the latest Periods table from the API
     * @returns {Promise<array>} array of period records
     */
    async function getPeriodsData() {
        console.log("RapidShade: Fetching periods table via API");
        const tableData = await grist.docApi.fetchTable(config.tables.PERIODS);
        console.log("RapidShade: Raw periods data:", tableData);
        const records = normalizeTableData(tableData);
        console.log("RapidShade: Normalized periods records:", records);
        return records;
    }

    /**
     * Prompts the user to select a target period via dropdown
     * @param {array} periods - array of period records
     * @returns {Promise<number|null>} selected period id or null
     */
    async function promptForPeriod(periods) {
        if (!Array.isArray(periods) || periods.length === 0) {
            console.log("RapidShade: No periods data available to prompt for period");
            return null;
        }
        const select = document.getElementById('period-select');
        select.innerHTML = '';
        periods.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = p.fields.Name;
            select.appendChild(option);
        });
        setUIState('selecting');
        return new Promise(resolve => { resolvePeriodSelection = resolve; });
    }

    // Handle confirm/cancel button clicks
    document.getElementById('confirm-duplication').addEventListener('click', () => {
        const sel = parseInt(document.getElementById('period-select').value, 10);
        console.log(`RapidShade: Period selected ${sel}`);
        resolvePeriodSelection(sel);
    });
    document.getElementById('cancel-duplication').addEventListener('click', () => {
        console.log("RapidShade: Duplication cancelled by user");
        resolvePeriodSelection(null);
        setUIState('initial');
    });

    /**
     * Core logic: duplicates the selected event and its related records
     * Step 1: Fetch periods & prompt selection
     * Step 2: Create new Event record
     * Step 3: Copy PeriodBudgetVersions
     * Step 4: Copy ProjectedBudgets
     * Step 5: Copy Expenses + ExpenseDetails
     * Step 6: Copy Revenues + RevenueDetails
     */
    async function duplicateEvent(sourceEvent) {
        if (!sourceEvent) return;
        console.log(`RapidShade: Starting duplication for event ${sourceEvent.id}`);
        try {
            // Prompt for period
            setUIState('processing', 'Fetching period data...');
            const periods = await getPeriodsData();
            const targetPeriodId = await promptForPeriod(periods);
            if (!targetPeriodId) return setUIState('info', 'Duplication cancelled.');

            // Create new event
            setUIState('processing', 'Creating new event...');
            console.log(`RapidShade: Creating new Event under Period ${targetPeriodId}`);
            const [newEventId] = await grist.docApi.addRecords(config.tables.EVENTS, [{
                Name: `${sourceEvent.Name} (Copy)`,
                Sport: sourceEvent.Sport,
                Period: targetPeriodId,
                LocationScope: sourceEvent.LocationScope,
                EventStatus: 1,
                EventType: sourceEvent.EventType,
                DateStart: null,
                DateEnd: null,
                Notes: null,
            }]);

            // Duplicate budget version
            setUIState('processing', 'Duplicating budget version...');
            const pbvs = allTables.PeriodBudgetVersions.filter(pb => pb.fields.Event === sourceEvent.id);
            let srcPBV = pbvs.find(pb => pb.fields.IsActive)
                || pbvs.sort((a,b) => new Date(b.fields.Created) - new Date(a.fields.Created))[0];
            if (srcPBV) {
                const data = {};
                Object.entries(srcPBV.fields).forEach(([c,v]) => {
                    if (c !== 'id' && c !== 'Event') data[c] = v;
                });
                data.Event = newEventId;
                console.log(`RapidShade: Copying PeriodBudgetVersions ${srcPBV.id}`);
                await grist.docApi.addRecords(config.tables.PERIOD_BUDGET_VERSIONS, [data]);
            }

            // Duplicate projected budgets
            setUIState('processing', 'Duplicating projected budgets...');
            const pbs = allTables.ProjectedBudgets.filter(pb => pb.fields.Event === sourceEvent.id);
            if (pbs.length) {
                await grist.docApi.addRecords(config.tables.PROJECTED_BUDGETS, pbs.map(x => ({
                    Event: newEventId,
                    Sport: x.fields.Sport,
                    ProjectedExpenses: x.fields.ProjectedExpenses,
                    ProjectedRevenues: x.fields.ProjectedRevenues,
                })));
            }

            // Duplicate expenses + details
            setUIState('processing', 'Duplicating expenses...');
            for (const exp of allTables.Expenses.filter(e => e.fields.Event === sourceEvent.id)) {
                const [newExp] = await grist.docApi.addRecords(config.tables.EXPENSES, [{
                    Event: newEventId,
                    Category: exp.fields.Category,
                    Budget: exp.fields.Budget,
                    Projected: exp.fields.Projected,
                    Actual: 0,
                    Notes: null,
                }]);
                console.log(`RapidShade: Created expense ${newExp}`);
                const details = allTables.ExpenseDetails.filter(d => d.fields.Expense === exp.id);
                if (details.length) {
                    await grist.docApi.addRecords(config.tables.EXPENSE_DETAILS, details.map(d => ({
                        Expense: newExp,
                        Event: newEventId,
                        Supplier: d.fields.Supplier,
                        Description: d.fields.Description,
                        Budget: d.fields.Budget,
                        Actual: 0,
                        Notes: null,
                    })));
                }
            }

            // Duplicate revenues + details
            setUIState('processing', 'Duplicating revenues...');
            for (const rev of allTables.Revenues.filter(r => r.fields.Event === sourceEvent.id)) {
                const [newRev] = await grist.docApi.addRecords(config.tables.REVENUES, [{
                    Event: newEventId,
                    Category: rev.fields.Category,
                    Budget: rev.fields.Budget,
                    Projected: rev.fields.Projected,
                    Actual: 0,
                    Notes: null,
                }]);
                console.log(`RapidShade: Created revenue ${newRev}`);
                const revDetails = allTables.RevenueDetails.filter(d => d.fields.Revenue === rev.id);
                if (revDetails.length) {
                    await grist.docApi.addRecords(config.tables.REVENUE_DETAILS, revDetails.map(d => ({
                        Revenue: newRev,
                        Event: newEventId,
                        Supplier: d.fields.Supplier,
                        Description: d.fields.Description,
                        Budget: d.fields.Budget,
                        Actual: 0,
                        Notes: null,
                    })));
                }
            }

            // Final success state
            setUIState('success', `Event '${sourceEvent.Name}' duplicated successfully!`);
            console.log("RapidShade: Duplication complete");
        } catch (err) {
            // Handle any errors during duplication
            console.error("RapidShade: Error during duplication:", err);
            setUIState('error', `Error during duplication: ${err.message}`);
        }
    }

    // Initialize plugin: request full access and fetch static tables
    grist.ready({
        requiredAccess: 'full',
        columns: [config.triggerColumn],
        tables: Object.values(config.tables)
    });

    // Fetch static tables once and store them
    Promise.all([
        grist.docApi.fetchTable(config.tables.EVENTS),
        grist.docApi.fetchTable(config.tables.PROJECTED_BUDGETS),
        grist.docApi.fetchTable(config.tables.EXPENSES),
        grist.docApi.fetchTable(config.tables.EXPENSE_DETAILS),
        grist.docApi.fetchTable(config.tables.REVENUES),
        grist.docApi.fetchTable(config.tables.REVENUE_DETAILS),
        grist.docApi.fetchTable(config.tables.PERIOD_BUDGET_VERSIONS),
    ]).then(([evts, pbs, exps, exd, revs, rvd, pbvs]) => {
        allTables = {
            Events: normalizeTableData(evts),
            ProjectedBudgets: normalizeTableData(pbs),
            Expenses: normalizeTableData(exps),
            ExpenseDetails: normalizeTableData(exd),
            Revenues: normalizeTableData(revs),
            RevenueDetails: normalizeTableData(rvd),
            PeriodBudgetVersions: normalizeTableData(pbvs),
        };
        console.log("RapidShade: Loaded static tables into memory");
        grist.onRecord(duplicateEvent);
    }).catch(err => {
        console.error("RapidShade: Failed to load initial data:", err);
        setUIState('error', 'Failed to load initial data. Check table/column names.');
    });
</script>
</body>
</html>
